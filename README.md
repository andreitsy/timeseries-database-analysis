# Исследование производительности no-sql и sql решений для хранения time-series данных

*Цель проекта*: посмотреть на разные подходы для хранения time-series данных, используя sql или no-sql, или же специализированное решение. При этом, интересно оценить перфолента и то как просто решить задачу средствами СУБД можно решить задачу по вычислению простых аналитических запросов.

## Схема данных

Данные устроены очень просто - это записи высокочастотных торгов (точность вплоть до наносекунд) т. н. trades и quotes для различных тикеров по дням. Схема выглядит следующим образом.

Требуется максимально быстро отвечать на различные аналитические запросы.

![schema](pictures/sql-schema.JPEG)
*Схема данных*
- **TIMESTAMP** - время продажи *trades* или обновления *quotes*
- **OMDSEQ** - уникальный идентификатор, задающий порядок, в случае если timestamp'ы совпадают
- **SYMBOL** - имя тикера
- **ASK_SIZE** - это количество ценной бумаги, которую маркет-мейкер предлагает продать по цене спроса
- **BID_SIZE** - это количество ценной бумаги, которую маркет-мейкер предлагает купить по цене предложения
- **ASK_PRICE** - цена спроса
- **BID_PRICE** - цена предложения
- **PRICE** - цена сделки
- **SIZE** - размер сделки

Запросы:

- Вычисление [The Lee–Ready algorithm](https://doi.org/10.1111/j.1540-6261.1991.tb02683.x)

- Агрегации: средняя цена за один день, VWAP.

Данные в базы могут быть загружены с помощью [скрипта](scripts/load_data_dbs.py). При этом пример исходных файлов лежит в директории *data*.

### SQL
В качестве SQL решения использую **PostgresSQL**.
И схема двух таблиц **quotes** и **trades** приведена выше.

При этом я создаю индекс для поля **SYMBOL**, поскольку частыми операциями являются группировки по этому полю, либо же join'ы.


### No-SQL
В качесте базы No-SQL используется **MongoDB**.

Создано две коллекции:
- **quotes** с записями из файла **.*_qte.csv**
- **trades** с записями из файла **.*_trd.csv**



### Time Series Database

Используется база InfluxDB как самое наилучшее решение согласно [рейтингу](https://db-engines.com/en/ranking/time+series+dbms).

![](pictures/ranks.JPEG)
*DB-Engines Ranking of Time Series DBMS*


## Результаты

### Плюсы SQL для хранения временных рядов
- Иерархические данные временных рядов естественным образом сочетаются с реляционными таблицами. 
- Если ременной ряд основан на транзакционных данных, то будет выгодно хранить временные ряды в той же базе данных для удобства проверки, перекрестных ссылок и т.д. Как вариант стоило посмотреть в сторону **Timescale**.

### Плюсы No-SQL для хранения  временных рядов
- Записи выполняются быстро, поскольку нет нужды перестраивать индексы
- Требование миграции при изменении схемы
- Более производительное готовое решение, потому с меньшей вероятностью можно создать неудобную схему